---
title: lets bang bytes in wasm
date: 01-26-2023
blurb: isn't this so fucking cool?
---

# me + web assembly = ðŸ’–
oh how i love WASM. it's not even funny (maybe a little, considering my hate for java).
granted the JVM is perhaps just a little different, but bytecode this bytecode that.

i want to make you agree with me through my powers of unadulterated rhetoric. and perhaps a little fun.

the world's simplest web assembly binary can be expressed as such:

<code>
```
# you can copy and paste this! #
0x00 0x61 0x73 0x6d # magic 0 A S M #
0x01 0x00 0x00 0x00 # version 1 0 0 0 #
```
</code>

how would you like to write some raw bytecode? "yes!" i hear you cry.

<BytecodeCompiler id="0" hint="0x00 0x61..."/>

let's talk about how wasm works for a moment.

web assembly is a very thoughtfully crafted virtual stack machine.
it takes structured sequences of bytes (opcodes) and performs mutations
on the stack itself.

there are only four data types in wasm, i32, i64, f32, f64.
the table of instrunctions available is actually very simple.

[this table](https://pengowray.github.io/wasm-ops/) by Pengo Wray is utterly *fantastic*.

i'll write out a small portion here and see what we can get up to.

```
opcode (param) : (what it do)
0x21 X : set local variable @ id from next byte popping from top of the stack.
    stack = [42]
    0x21 0x00 : local_variables[0] = 42 --> stack = []

0x20 X : gets a local i32  @ id from next byte adding to the top of the stack.
    stack = [0]
    0x20 0x00 : stack.append(local_variables[0]) -->stack = [0, 42]

0x41 X:i32 : adds the next byte (i32) to the top of the stack.
    stack = []
    0x41 0x0a : stack.append(0x0a) --> stack = [10]
    # caveat on this, if the number is over some size you have to use leb128
    # you do not have to worry about this as i will provide a wrapper for it
    # but should you write your own WASM things, it will be necessary to resolve this. 
0x6A : pops two i32s from the stack and appends the sum of them to the stack.
    stack = [5:i32, 6:i32]
    0x6A : stack.append(stack.pop() + stack.pop()) --> stack = [11:i32]
0x0F : jump to outermost block and return the values off the stack.
```

